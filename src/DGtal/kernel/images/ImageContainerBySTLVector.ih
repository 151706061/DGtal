/**
 * @file ImageContainerBySTLVector.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/06/15
 *
 * Implementation of inline methods defined in ImageContainerBySTLVector.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

template <typename Point, typename T>
inline
ImageContainerBySTLVector<Point,T>::ImageContainerBySTLVector(const Point &aPointA,
        const Point &aPointB )
{
    if (aPointA < aPointB)
    {
        myLowerBound = aPointA;
        myUpperBound = aPointB;
    }
    else
    {
        myLowerBound = aPointB;
        myUpperBound = aPointA;
    }
}

template <typename Point, typename T>
inline
ImageContainerBySTLVector<Point,T>::~ImageContainerBySTLVector( )
{
}


template <typename Point, typename T>
inline
T
ImageContainerBySTLVector<Point,T>::operator()(const Point &aPoint)
{
    return this->at( linearized( aPoint ) );

}

template <typename Point, typename T>
inline
void
ImageContainerBySTLVector<Point,T>::setValue(const Point &aPoint, const T &V)
{
  this->at( linearized( aPoint ) ) = V;
}

///////////////////////////////////////////////////////////////////////////////
// Helper classes defined in the compilation unit (anonymous namespace)

namespace {

  /**
   * Class template for linearization of the coordinates of a Point.
   * This class template is to be specialized for efficiency for dimensions 1,
   * 2 and 3 to prevent the use of a loop in these cases.
   * 
   */
  template < typename Point, int Dimension, typename SizeType >
  struct linearizer {

    /** 
     * Compute the linearized offset of a point in a vector container.
     * 
     * @param aPoint A point
     * @param lowerBound The lower bound of the image domain.
     * @param upperBound The upper bound of the image domain.
     * 
     * @return 
     */
    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      SizeType pos = aPoint[ 0 ] - lowerBound[ 0 ] ;
      SizeType multiplier = 1;
      for (unsigned int k = 1 ; k < Point::Dimension ; ++k)
	{
	  multiplier *= 1 + ( upperBound[ k-1  ] - lowerBound[ k-1 ] );
	  pos += multiplier * ( aPoint[ k ] - lowerBound[ k ] );
	} 
      return pos;
    }
  };

  /**
   * Specialization of the linearizer class for dimension 1.
   * 
   */
  template < typename Point, typename SizeType >
  struct linearizer< Point, 1, SizeType > {
    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      return aPoint[ 0 ] - lowerBound[ 0 ];
    }
  };

  /**
   * Specialization of the linearizer class for dimension 2.
   * 
   */
  template < typename Point, typename SizeType >
  struct linearizer< Point, 2, SizeType > {
    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      SizeType multiplier = 1 + upperBound[ 0 ] - lowerBound[ 0 ];    
      return ( aPoint[ 0 ] - lowerBound[ 0 ] ) + multiplier * (aPoint[ 1 ] - lowerBound[ 1 ] ); 
    }
  };

  /**
   * Specialization of the linearizer class for dimension 3.
   * 
   */
  template < typename Point, typename SizeType >
  struct linearizer< Point, 3, SizeType > {
    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      SizeType res = aPoint[ 0 ] - lowerBound[ 0 ];
      SizeType multiplier = 1 + upperBound[ 0 ] - lowerBound[ 0 ];
      res += multiplier * ( aPoint[ 1 ] - lowerBound[ 1 ] );  
      multiplier *= 1 + upperBound[ 1 ] - lowerBound[ 1 ];
      res += multiplier * ( aPoint[ 2 ] - lowerBound[ 2 ] );
      return res;
    }
  };
}



///////////////////////////////////////////////////////////////////////////////
// Internals - private :
template<typename Point, typename T>
inline
typename ImageContainerBySTLVector<Point,T>::SizeType
ImageContainerBySTLVector<Point,T>::linearized(const Point &aPoint) const
{
  return linearizer<Point, Point::Dimension, SizeType >::apply( aPoint, myLowerBound, myUpperBound );
}

