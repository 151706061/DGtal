/**
 * @file ImageContainerBySTLVector.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/06/15
 *
 * Implementation of inline methods defined in ImageContainerBySTLVector.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

template <typename TPoint, typename T>
inline
ImageContainerBySTLVector<TPoint,T>::ImageContainerBySTLVector(const TPoint &aPointA,
        const TPoint &aPointB )
{
    if (aPointA < aPointB)
    {
        myLowerBound = aPointA;
        myUpperBound = aPointB;
    }
    else
    {
        myLowerBound = aPointB;
        myUpperBound = aPointA;
    }
}

template <typename TPoint, typename T>
inline
ImageContainerBySTLVector<TPoint,T>::~ImageContainerBySTLVector( )
{
}


template <typename TPoint, typename T>
inline
T
ImageContainerBySTLVector<TPoint,T>::operator()(const TPoint &aPoint)
{
    return this->at( linearized( aPoint ) );

}

template <typename TPoint, typename T>
inline
void
ImageContainerBySTLVector<TPoint,T>::setValue(const TPoint &aPoint, const T &V)
{
  this->at( linearized( aPoint ) ) = V;
}



///////////////////////////////////////////////////////////////////////////////
// Internals - private :
template<typename TPoint, typename T>
inline
typename ImageContainerBySTLVector<TPoint,T>::TSizeType
ImageContainerBySTLVector<TPoint,T>::linearized(const TPoint &aPoint) const
{
    TSizeType pos = aPoint.at( 0 )- this->myLowerBound.at( 0 ) ;
    TSizeType multiplier = 1;

    for (unsigned int k = 1 ; k < TPoint::Dimension ; k++)
    {
        multiplier *= (this->myUpperBound.at( k-1 ) - this->myLowerBound.at ( k-1 ));
        pos += multiplier * ( aPoint.at( k ) - this->myLowerBound.at( k ) );
    }

    return pos;
}

